<!DOCTYPE html>
<html>
<head><title>Timeline Prototype</title></head>
<body>
  <pg-timeline-viewer width="1000px" height="400px" x-axis="time">
    <pg-timeline>
      <pg-event x="20" label="Foo"></pg-event>
      <pg-event start-x="25" end-x="30" label="Bar"></pg-event>
    </pg-timeline>
  </pg-timeline-viewer>
</body>
<script>
const polygraph = (() => {
  'use strict';
  
  const polygraph = {};
      
  class AbstractMethodError {}
  
  const noLog = () => {};
  
  const compare = (lhs, rhs) => {
    if ( lhs < rhs ) {
      return -1;
    } else if ( lhs === rhs ) {
      return 0;
    } else {
      return 1;
    }
  };
        
  const ranges = (() => {
    const ranges = {};
    
    const log = noLog;
    
    ranges.Range = class {
      constructor(min, max) {
        this._min = min;
        this._max = max;
        
        Object.freeze(this);
      }
      
      get min() {
        return this._min;
      }
      
      get max() {
        return this._max;
      }
    };
    
    ranges.RangeBuilder = class {
      constructor(optCompareFn) {
        this._compareFn = optCompareFn || compare;
      }
      
      record(val) {
        if ( typeof this._min === 'undefined' ) {
          this._min = val;
          this._max = val;
        } else {
          const compareFn = this._compareFn;
        
          if ( compareFn(val, this._min) < 0 ) {
            this._min = val;
          } else if ( compareFn(val, this._max) > 0 ) {
            this._max = val;
          }
        }
      }
      
      recordRange(min, max) {
        log('before recordRange', this);
        log('recordRange', min, max);
        
        if ( typeof this._min === 'undefined' ) {
          this._min = min;
          this._max = max;
        } else {
          const compareFn = this._compareFn;
        
          if ( compareFn(min, this._min) < 0 ) {
            this._min = min;
          }
          if ( compareFn(min, this._max) > 0 ) {
            this._max = max;
          }
        }
        
        log('after recordRange', this);
      }
      
      recordRangeObj(rangeObj) {
        this.recordRange(rangeObj.min, rangeObj.max);
      }
      
      make() {
        return new ranges.Range(this._min, this._max);
      }
    };
    
    Object.freeze(ranges);
    return ranges;
  })();
  
  const axes = (() => {
    const axes = {};
    
    axes.Axis = class {
      compare(lhsVal, rhsVal) {
        if ( lhsVal < rhsVal ) {
          return -1;
        } else if ( lhsVal == rhsVal ) {
          return 0;
        } else {
          return 1;
        }
      }
      
      deserialize(str) {
        return str;
      }
    
      translate(val) {
        throw new AbstractMethodError('translate');
      }
      
      format(val) {
        return val;
      }
    };
    
    axes.NumericAxis = class extends axes.Axis {
      deserialize(str) {
        return Number(str);
      }
      
      translate(val) {
        return val;
      }
    };
    
    // TODO: Switch to dictionary
    const defs = {};
    axes.define = (name, axis) => {
      defs[name] = axis;
    };
    
    Object.freeze(axes);
    return axes;
  })();
  
  
  polygraph.Axis = axes.Axis;
  polygraph.defineAxis = (name, axis) => {
    axis.define(name, axis);
  };

  const properties = (() => {
    const properties = {};
    
    const log = noLog; // console.log;
    
    class AbstractElementProperty {
      constructor(element, prop, options) {
        this._element = element;
        this._prop = prop;
        
        this._options = options;
      }
      
      getter() {
        throw AbstractMethodError('get');
      }
      
      setter(val) {
        throw AbstractMethodError('set(val)');
      }
      
      connect(element) {
        log('connect property', element, this._prop, this);
        
        Object.defineProperty(
          element,
          this._prop,
          {
            get: () => this.getter(),
            set: (val) => this.setter(val)
          });
      
        if ( element.hasAttribute(this._prop) ) {
          element[this._prop] = element.getAttribute(this._prop);
        } else if ( typeof this._options.defaultValue !== 'undefined' ) {
          element.setAttribute(this._prop, this._options.defaultValue);
          element[this._prop] = this._options.defaultValue;
        }
      }
    }
    
    properties.AttributeProperty = class extends AbstractElementProperty {
      constructor(element, prop, options) {
        super(element, prop, options);
        
        log('AttributeProperty', element, prop);
      }
      
      getter() {
        return this._element.getAttribute(this._prop);
      }
      
      setter(val) {
        log('set attr', this, this._element, this._prop, val);
      
        this._element.setAttribute(this._prop, val);
      }
    };
    
    properties.AttributeNSProperty = class extends AbstractElementProperty {
      constructor(element, ns, prop, options) {
        super(element, prop, options);
        this._ns = ns;
        
        log('AttributeNSProperty', element, ns, prop);
      }
      
      getter() {
        return this._element.getAttributeNS(this._ns, this._prop);
      }
      
      setter(val) {
        log('set attrNS', this, this._element, this._ns, this._prop, val);
      
        this._element.setAttributeNS(this._ns, this._prop, val);
      }
    }
    
    properties.StyleProperty = class extends AbstractElementProperty {
      constructor(element, prop, options) {
        super(element, prop, options);
        
        log('StyleProperty', element, prop);
      }
      
      getter() {
        return this._element.style[this._prop];
      }
      
      setter(val) {
        log('set style', this, this._element, this._prop, val);
        
        this._element.style[this._prop] = val;
      }
    }
    
    Object.freeze(properties);
    return properties;
  })();
  
  const svg = (() => {
    const svg = {};
    
    svg.ns = 'http://www.w3.org/2000/svg';
    
    svg.create = (tag, optAttrs) => {
      return document.createElementNS(svg.ns, tag);
    };
    
    svg.attr = (element, attr, value) => {
      document.setAttributeNS(null, attr, value);
    };
    
    svg.attrs = (element, attrs) => {
      for (let attr in attrs ) {
        document.setAttributeNS(null, attr, attrs[attr]);
	  }
    };
    
    svg.line = (x1, y1, x2, y2) => {
      return svg.create('line', {x1: x1, y1: y1, x2: x2, y2: y2});
    };
    
    Object.freeze(svg);
    return svg;
  })();
  
  const viewport = (() => {
    const viewport = {};
    
    viewport.AbstractAxisModel = class {
      constructor(viewport, optAxis) {
        this._axis = optAxis || new axes.NumericAxis();
        
        this._viewports = [];
        this.addViewport(viewport);
      }
      
      addViewport(viewport) {
        this._viewports.push(viewport);
      }
      
      translate(val) {
        return this._axis.translate(val);
      }
      
      deserialize(str) {
        return this._axis.deserialize(str);
      }
      
      createRangeBuilder() {
        const compareFn = this._axis.compare.bind(this._axis);
        return new ranges.RangeBuilder(compareFn);
      }
      
      get range() {
        throw new AbstractMethodError('range');
      }
    };
    
    viewport.XAxisModel = class extends viewport.AbstractAxisModel {
      get range() {
        const rangeBuilder = this.createRangeBuilder();
        this._viewports.forEach((viewport) => {
          rangeBuilder.recordRangeObj(viewport.requiredXRange);
        });
        return rangeBuilder.make();
      }
    };
    
    viewport.YAxisModel = class extends viewport.AbstractAxisModel {
      get range() {
        const rangeBuilder = this.createRangeBuilder();
        this._viewports.forEach((viewport) => {
          rangeBuilder.recordRangeObj(viewport.requiredYRange);
        });
        return rangeBuilder.make();
      }
    };
    
    viewport.SvgViewportMixin = class {
      constructor() {
        this._div = document.createElement('div');
        this._svg = document.createElementNS(svg.ns, 'svg');
      
        this._div.appendChild(this._svg);
        
        // TODO: Defer construction once sync is supported?
        this._xAxisModel = new viewport.XAxisModel(this);
        this._yAxisModel = new viewport.YAxisModel(this);
      }
      
      get element() {
        return this._div;
      }
      
      get boundingRect() {
        return this._div.getBoundingClientRect();
      }
      
      get svgElement() {
        return this._svg;
      }
      
      connect(viewerElement) {
        this._viewer = viewerElement;
      
        const widthProp = new properties.StyleProperty(this._div, 'width');
        widthProp.connect(viewerElement);
      
        const heightProp = new properties.StyleProperty(this._div, 'height');
        heightProp.connect(viewerElement);
        
        const overflowXProp = new properties.StyleProperty(this._div, 'overflow-x', {
          defaultValue: 'auto'
        });
        overflowXProp.connect(viewerElement);
        
        const overflowYProp = new properties.StyleProperty(this._div, 'overflow-y', {
          defaultValue: 'auto'
        });
        overflowYProp.connect(viewerElement);
      }
    
      connectXAxis(viewerElement) {
      
      }
    
      connectYAxis(viewerElement) {
      
      }
      
      set xAxis(xAxis) {
        this._xAxisModel.axis = xAxis;
      }
      
      get xAxis() {
        return this._xAxisModel.axis;
      }
      
      set yAxis(yAxis) {
        this._yAxisModel.axis = yAxis;
      }
      
      get yAxis() {
        return this._yAxisModel.axis;
      }
      
      createXRangeBuilder() {
        return this._xAxisModel.createRangeBuilder();
      }
      
      createYRangeBuilder() {
        return this._yAxisModel.createRangeBuilder();
      }
      
      deserializeX(str) {
        return this._xAxisModel.deserialize(str);
      }
      
      deserializeY(str) {
        return this._yAxisModel.deserialize(str);
      }
      
      transX(x) {
        return this._xAxisModel.translate(x);
      }
      
      transY(y) {
        return this._yAxisModel.translate(y);
      }
      
      get requiredXRange() {
        return this._viewer.xRange;
      }
      
      get requiredYRange() {
        return this._viewer.yRange;
      }
      
      get xRange() {
        return this._xAxisModel.range;
      }
      
      get yRange() {
        return this._yAxisModel.range;
      }
    }
    
    Object.freeze(viewport);
    return viewport;
  })();

  
  class AbstractViewer extends HTMLElement {
    constructor() {
      super();
      
      const shadowRoot = this.attachShadow({mode: 'open'});
      
      this._viewport = new viewport.SvgViewportMixin();
      shadowRoot.appendChild(this._viewport.element);
    }
  }

  
  const timeline = (() => {
    const timeline = {};
    
    const log = noLog;
    
    timeline.SwimlaneAxis = class extends axes.Axis {
      static get DEFAULT_SPACING_PX() { return 50; }
    
      constructor(optSpacingPx) {
        super();
        
        this._spacingPx = optSpacingPx || 
          timeline.SwimlaneAxis.DEFAULT_SPACING_PX;
      }
    };
    
    timeline.TimelineViewer = class extends AbstractViewer {
      static get ELEMENT_NAME() { return 'pg-timeline-viewer'; }
      
      constructor() {
        super();
      }
    
      connectedCallback() {
        log('connectedCallback', this);
        
        this._viewport.connect(this);
        
        this._viewport.connectXAxis(this);
        this._viewport.yAxis = new timeline.SwimlaneAxis();
        
        timeline.whenDefined().then(() => this.render());
      }
      
      get timelines() {
        return this.querySelectorAll(timeline.Timeline.ELEMENT_NAME);
      }
      
      get xRange() {
        const timelines = this.timelines;
        
        const rangeBuilder = this._viewport.createXRangeBuilder();
        for ( let i = 0; i < timelines.length; ++i ) {
          rangeBuilder.recordRangeObj(timelines[i].xRange);
        }
        return rangeBuilder.make();
      }
      
      get yRange() {
        return new ranges.Range(0, this.timelines.length);
      }
      
      render() {
        console.log('TimelineViewer.render', this.xRange, this.yRange);
        
        console.log('viewport', this._viewport.xRange, this._viewport.yRange);
        
        const boundingRect = this._viewport.boundingRect;
        console.log('boundingRect', boundingRect);
        
        
        
        
//         const timelines = this.timelines;
//         for ( let i = 0; i < timelines.length; ++i ) {
//           timelines[i].render(this._viewport, this._viewport, i);
//         }
      }
    };
    
    timeline.Timeline = class extends HTMLElement {
      static get ELEMENT_NAME() { return 'pg-timeline' };
      
      constructor() {
        super();
      }
      
      get _viewport() {
        return this.parentNode._viewport;
      }
    
      set label(label) {
        return this.setAttribute('label', label);
      }
    
      get label() {
        this.getAttribute('label');
      }
      
      get events() {
        return this.querySelectorAll(timeline.TimelineEvent.ELEMENT_NAME);
      }
      
      get xRange() {
        const events = this.events;
        
        const rangeBuilder = this._viewport.createXRangeBuilder();
        for ( let i = 0; i < events.length; ++i ) {
          rangeBuilder.recordRange(events[i].startX, events[i].endX);
        }
        return rangeBuilder.make();
      }
      
      render(viewport, index) {
        const xRange = viewport.xRange;
        const x1 = viewport.transX(xRange.min);
        const x2 = viewport.transX(xRange.max);
        const y = viewport.transY(index);
        
        viewport.svgElement.appendChild(svg.line(x1, y, x2, y));
      }
    };
  
    timeline.TimelineEvent = class extends HTMLElement {
      static get ELEMENT_NAME() { return 'pg-event' };
      
      constructor() {
        super();
      }
      
      connectedCallback() {
        if ( this.hasAttribute('x') ) {
          const x = this.getAttribute('x');
          this.setAttribute('start-x', x);
          this.setAttribute('end-x', x);
        }
      }
      
      get _viewport() {
        return this.parentNode._viewport;
      }
    
      set label(label) {
        return this.setAttribute('label', label);
      }
    
      get label() {
        return this.getAttribute('label');
      }
    
      set x(x) {
        this.startX = x;
        this.endX = x;
      }
      
      get x() {
        const startX = this.startX;
        const endX = this.endX;
        
        if ( startX === endX ) return startX;
      }
    
      set startX(x) {
        this.setAttribute('start-x', x);
      }
    
      get startX() {
        return this._viewport.deserializeX(this.getAttribute('start-x'));
      }
    
      set endX(x) {
        this.setAttribute('end-x', x);
      }
    
      get endX() {
        return this._viewport.deserializeX(this.getAttribute('end-x'));
      }
    };
    
    timeline.init = () => {
      window.customElements.define(
        timeline.TimelineViewer.ELEMENT_NAME,
        timeline.TimelineViewer);
        
      window.customElements.define(
        timeline.Timeline.ELEMENT_NAME,
        timeline.Timeline);
        
      window.customElements.define(
        timeline.TimelineEvent.ELEMENT_NAME,
        timeline.TimelineEvent);
    };
    
    timeline.whenDefined = () => {
      return Promise.all([
        window.customElements.whenDefined(timeline.TimelineViewer.ELEMENT_NAME),
        window.customElements.whenDefined(timeline.Timeline.ELEMENT_NAME),
        window.customElements.whenDefined(timeline.TimelineEvent.ELEMENT_NAME)
      ]);
    }
    
    Object.freeze(timeline);
    return timeline;
  })();
    
  polygraph.init = () => {
    timeline.init();
  };
  
  Object.freeze(polygraph);
  return polygraph;
})();

polygraph.init();
</script>
</html>