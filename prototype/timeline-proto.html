<!DOCTYPE html>
<html>
<head><title>Timeline Prototype</title></head>
<body>
  <pg-timeline-viewer width="1000px" height="400px" x-axis="time">
    <pg-timeline>
      <pg-event x="20" label="Foo" />
      <pg-event start-x="25" end-x="30" label="Bar" />
    </pg-timeline>
  </pg-timeline-viewer>
</body>
<script>
const polygraph = (() => {
  'use strict';
  
  const polygraph = {};
  
  const svgNs = 'http://www.w3.org/2000/svg';
    
  class AbstractMethodError {}
  
  class Axis {
    min(lhsVal, rhsVal) {
      return ( lhsVal <= rhsVal ) ? lhsVal : rhsVal;
    }
    
    toPixel(val, minVal, maxVal, maxPixel) {
      throw new AbstractMethodError('toPixel');
    }
  }
  polygraph.Axis = Axis;
  
  
  // TODO: Switch to dictionary?
  const axisDefs = {};
  polygraph.defineAxis = (name, axis) => {
    axisDefs[name] = axis;
  };
  
  class RawAxis extends Axis {
    toPixel(val, minVal, maxVal, maxPixel) {
      return val;
    }
  }

  const properties = (() => {
    const properties = {};
    
    const log = () => {}; // console.log;
    
    class AbstractElementProperty {
      constructor(element, prop, options) {
        this._element = element;
        this._prop = prop;
        
        this._options = options;
      }
      
      getter() {
        throw AbstractMethodError('get');
      }
      
      setter(val) {
        throw AbstractMethodError('set(val)');
      }
      
      connect(element) {
        log('connect property', element, this._prop, this);
        
        Object.defineProperty(
          element,
          this._prop,
          {
            get: () => this.getter(),
            set: (val) => this.setter(val)
          });
      
        if ( element.hasAttribute(this._prop) ) {
          element[this._prop] = element.getAttribute(this._prop);
        } else if ( typeof this._options.defaultValue !== 'undefined' ) {
          element.setAttribute(this._prop, this._options.defaultValue);
          element[this._prop] = this._options.defaultValue;
        }
      }
    }
    
    properties.AttributeProperty = class extends AbstractElementProperty {
      constructor(element, prop, options) {
        super(element, prop, options);
        
        log('AttributeProperty', element, prop);
      }
      
      getter() {
        return this._element.getAttribute(this._prop);
      }
      
      setter(val) {
        log('set attr', this, this._element, this._prop, val);
      
        this._element.setAttribute(this._prop, val);
      }
    };
    
    properties.AttributeNSProperty = class extends AbstractElementProperty {
      constructor(element, ns, prop, options) {
        super(element, prop, options);
        this._ns = ns;
        
        log('AttributeNSProperty', element, ns, prop);
      }
      
      getter() {
        return this._element.getAttributeNS(this._ns, this._prop);
      }
      
      setter(val) {
        log('set attrNS', this, this._element, this._ns, this._prop, val);
      
        this._element.setAttributeNS(this._ns, this._prop, val);
      }
    }
    
    properties.StyleProperty = class extends AbstractElementProperty {
      constructor(element, prop, options) {
        super(element, prop, options);
        
        log('StyleProperty', element, prop);
      }
      
      getter() {
        return this._element.style[this._prop];
      }
      
      setter(val) {
        log('set style', this, this._element, this._prop, val);
        
        this._element.style[this._prop] = val;
      }
    }
    
    return properties;
  })();  
  
  const viewport = (() => {
    const viewport = {};
    
    viewport.AxisModel = class {
      constructor(axis) {
        this._axis = axis;
      }
    
      min(lhsVal, rhsVal) {
        return this._xAxis.min(lhsVal, rhsVal);
      }
    
      get bounds() {
        return {min: this._min, max: this._max};
      }
    }
    
    viewport.SvgViewportMixin = class {
      constructor() {
        this._div = document.createElement('div');
        this._svg = document.createElementNS(svgNs, 'svg');
      
        this._div.appendChild(this._svg);
      }
    
      connect(viewerElement) {
        const widthProp = new properties.StyleProperty(this._div, 'width');
        widthProp.connect(viewerElement);
      
        const heightProp = new properties.StyleProperty(this._div, 'height');
        heightProp.connect(viewerElement);
        
        const overflowXProp = new properties.StyleProperty(this._div, 'overflow-x', {
          defaultValue: 'auto'
        });
        overflowXProp.connect(viewerElement);
        
        const overflowYProp = new properties.StyleProperty(this._div, 'overflow-y', {
          defaultValue: 'auto'
        });
        overflowYProp.connect(viewerElement);
      }
    
      connectXAxis(viewerElement) {
      
      }
    
      connectYAxis(viewerElement) {
      }
    
      get element() {
        return this._div;
      }
    }
    
    return viewport;
  })();

  
  class AbstractViewer extends HTMLElement {
    constructor() {
      super();
      
      const shadowRoot = this.attachShadow({mode: 'open'});
      
      this._viewport = new viewport.SvgViewportMixin();
      shadowRoot.appendChild(this._viewport.element);
    }
  }
  

  
  class Timeline extends HTMLElement {
    constructor() {
      super();
    }
    
    set label(label) {
      return this.setAttribute('label', label);
    }
    
    get label() {
      return this.getAttribute('label');
    }
  }
  
  const timeline = (() => {
    const timeline = {};
    
    timeline.TimelineViewer = class extends AbstractViewer {
      constructor() {
        super();
      }
    
      connectedCallback() {
        this._viewport.connect(this);
        
        this._viewport.connectXAxis(this);
      }
    }
  
    timeline.TimelineEvent = class extends HTMLElement {
      constructor() {
        super();
      }
    
      set label(label) {
        return this.setAttribute('label', label);
      }
    
      get label() {
        return this.getAttribute('label');
      }
    
      set x(x) {
        this.startX = x;
        this.endX = x;
      }
    
      set startX(x) {
        return this.getAttribute('start-x');
      }
    
      get startX() {
        return this.getAttribute('start-x');
      }
    
      set endX(x) {
        return this.setAttribute('end-x', x);
      }
    
      get endX() {
        return this.getAttribute('end-x');
      }
    }
    
    timeline.init = (prefix) => {
      window.customElements.define(prefix + '-timeline-viewer', timeline.TimelineViewer);
    };
    
    return timeline;
  })();
    
  polygraph.init = (optPrefix) => {
    const prefix = optPrefix || 'pg';
      
    timeline.init(prefix);
  };
  return polygraph;
})();

polygraph.init();
</script>
</html>