<!-- DOCTYPE html -->
<html>
<head><title>hello</title></head>
<script>
class NoNamespaceElementHelper {
  create(tag) {
    return document.createElement(tag);
  }
}

class NamespaceElementHelper {
  constructor(_namespace) {
    this._namespace = _namespace;
  }
  
  create(tag) {
    return document.createElementNS(this._namespace, tag);
  }
}

class SimpleAttributeHandler {
  setAttribute(node, name, value) {
    this._setAttribute(node, name, value);
  }
  
  _setAttribute(node, name, value) {
    node.setAttribute(name, value);
  }
}

class ComplexAttributeHelper extends SimpleAttributeHandler {
  constructor(options) {
    super();
    
    this._attrTranslation = options.attrTranslation || {};
    this._attrValueConverters = options.attrValueConverters || {};
  }
  
  setAttribute(node, name, value) {
    const normalizedName = this._attrTranslation[name] || name;
    
    const converter = this._attrValueConverters[normalizedName];
    if ( converter ) {
      this._setAttribute(node, normalizedName, converter(value));
    } else {
      this._setAttribute(node, normalizedName, value);
    }
  }
}

class DocumentBuilder {
  constructor(options) {
    options = options || {};
    
    if ( options.ns ) {
      this._elementHelper = new NamespaceElementHelper(options.ns);
    } else {
      this._elementHelper = new NoNamespaceElementHelper();
    }
    
    if ( options.attrTranslation || options.attrValueConverters ) {
      this._attrHelper = new ComplexAttributeHelper({
        attrTranslation: options.attrTranslation,
        attrValueConverters: options.attrValueConverters
      });
    } else {
      this._attrHelper = new SimpleAttributeHelper();
    }
    
    this._fragment = document.createDocumentFragment();
    this._curNode = null;
    this._leaf = false;
  }
  
  _open(tag) {
    if ( this._leaf ) this.close();
  
    const newNode = this._elementHelper.create(tag);
    
    if ( !this._curNode ) {
      this._fragment.appendChild(newNode);
    } else {
      this._curNode.appendChild(newNode);
    }
    this._curNode = newNode;
    
    return this;
  }

  open(tag, optContents) {
    this._open(tag);
    
    if ( optContents) this.contents(optContents);
    
    return this;
  }
  
  leaf(tag) {
    this._open(tag);
    this._leaf = true;
    return this;
  }
  
  id(id) {
    this._curNode.id = id;
  }
  
  _plainAttr(name, value) {
    this._curNode.setAttribute(name, str(value));
    
    return this;
  }

  attr(name, value) {
    this._attrHelper.setAttribute(this._curNode, name, value);
  }
  
  attrs(attrsObj) {
    for ( let name in attrsObj ) {
      this._attrHelper.setAttribute(this._curNode, name, attrsObj[name]);
    }
    
    return this;
  }
  
  datum(name, value) {
    // TODO: Use something else if available
    return this._plainAttr('data-' + name, value);
  }
  
  data(dataObj) {
    for ( let name in dataObj ) {
      this._plainAttr('data-'+ name, value);
    }
    
    return this;
  }
  
  class_(class_) {
    this._curNode.classList.add(class_);
    
    return this;
  }
  
  classes(...classes) {
    this._curNode.classList.add(classes);
    
    return this; 
  }
  
  style(name, value) {
    this._curNode.style[name] = value;
    
    return this;
  }
  
  styles(styleObj) {
    for ( const name in styleObj ) {
      this._curNode.style[name] = styleObj[name];
    }
    
    return this;
  }
  
  contents(contents) {
    if ( typeof contents === 'function' ) {
      const results = contents.apply(this);
      if ( results ) this._text(results);
    } else {
      this._text(contents);
    }
    
    if ( this._leaf ) this.close();
    this.close();
    
    return this;
  }
  
  textContents(value) {
    this.text(value);

    this.close();
    
    return this;
  }
  
  text(value) {
    if ( typeof value === 'function' ) {
      const result = value.apply();
      this._text(result);
    } else {
      this._text(result);
    }
    
    return this;
  }
  
  _text(value) {
    this._curNode.appendChild(document.createTextNode(value));
    
    return this;
  }
  
  close(tag) {
    this._curNode = this._curNode.parentElement;
    this._leaf = false;
    
    return this;
  }
  
  get() {
    return this._fragment;
  }
  
  appendTo(node) {
    node.appendChild(this._fragment);
  }
}

class HtmlBuilder {
  constructor() {
    this._docBuilder = new DocumentBuilder();
  }
  
  open(tag, optContents) {
    this._docBuilder.open(tag, optContents);
    return this;
  }
  
  table(optContents) {
    return this.open('table', optContents);
  }
  
  tbody(optContents) {
    return this.open('tbody', optConents);
  }
  
  tr(optContents) {
    return this.open('tr', optContents);
  }
  
  th(optContents) {
    return this.open('th', optContents);
  }
  
  td(optContents) {
    return this.open('td', optContents);
  }
  
  get() {
    return this._docBuilder.get();
  }
  
  appendTo(node) {
    this._docBuilder.appendTo(node);
  }
}

class TransformBuilder {
  constructor() {
    this._fragments = [];
  }  
  
  translate(translationObj) {
    if ( Array.isArray(translationObj) ) {
      this._fragments.push('translate(', translationObj.join(' '), ')');
    } else if ( typeof translationObj === 'object' ) {
      this._fragments.push(
        'translate(',
        translationObj.x || 0,
        ' ',
        translateObj.y || 0,
        ')');
    } else {
      this._fragments.push('translate(', translationObj, ')');
    }
    
    return this;
  }
  
  rotate(rotationObj) {
    if ( Array.isArray(rotationObj) ) {
      this._fragments.push('rotate(', rotationObj.join(','), ')');
    } else if ( typeof rotationObj === 'object' ) {
      this._fragments.push(
        'rotate(',
        rotationObj.a || 0,
        ' ',
        rotationObj.x || 0,
        ' ',
        rotationObj.y || 0,
        ')');
    } else {
      this._fragments.push('rotate(', rotationObj, ')');
    }
    
    return this;
  }
  
  make() {
    return this._fragments.join('');
  }
}

class PointsBuilder {
  constructor() {
    this._fragments = [];
  }
  
  point(...pt) {
    if ( typeof pt[0] === 'object' ) {
      this._fragments.push(pt.x + ',' + pt.y);
    } else {
      this._fragments.push(pt.join(' '));
    }
    return this;
  }
  
  points(...points) {
    if ( points.length == 1 && typeof points[0] === 'object' ) {
      points = points[0];
    }
    return this._points(points);
  }
    
  _points(points) {
    console.log('points', points);
    
    points.forEach((pt) => {
      if ( Array.isArray(pt) ) {
        this._fragments.push(pt[0] + ',' + pt[1]);
      } else {
        this._fragments.push(pt.x + ',' + pt.y);
      }
    });
    return this;
  }
  
  make() {
    return this._fragments.join(' ');
  }
}

const svg = {};

svg.ns = 'http://www.w3.org/2000/svg';

svg.attrTranslation = {
  strokeWidth: 'stroke-width'
};

svg.attrValueConverters = {
  transform: (value) => {
    if ( typeof value !== 'object' ) return value;
    const transformObj = value;
    
    const transformBuilder = new TransformBuilder();
    if ( transformObj.translate ) {
      transformBuilder.translate(transformObj.translate);
    }
    
    if ( transformObj.rotate ) {
      transformBuilder.rotate(transformObj.rotate);
    }    
    return transformBuilder.make();
  },
  
  points: (value) => {
    if ( typeof value === 'object' ) {
      const pointsArray = value;
      
      return new PointsBuilder().
        _points(pointsArray).
        make();
    } else if ( typeof value === 'function' ) {
      const pointsFn = value;
      
      // function can...
      // - take a PointsBuilder
      // - return an array of points
      // - return a string of points
      
      const pointsBuilder = new PointsBuilder();
      const points = pointsFn(pointsBuilder);
      
      if ( points ) {
        // recursive call to sort out what was returned
        return this.points(points); 
      } else {
        return pointsBuilder.make();
      }
    } else {
      return value;
    }
  }
};

class SvgBuilder {
  constructor() {
    this._docBuilder = new DocumentBuilder({
      ns: svg.ns,
      attrTranslation: svg.attrTranslation,
      attrValueConverters: svg.attrValueConverters
    });
  }
  
  open(tag, optContents) {
    this._docBuilder.open(tag, optContents);
    
    return this;
  }
  
  attr(name, value) {
    this._docBuilder.attr(name, value);
    
    return this;
  }
  
  attrs(attrsObj) {
    this._docBuilder.attrs(attrsObj);
    
    return this;
  }
  
  leaf(tag, optAttrsObj) {
    this._docBuilder.leaf(tag);
    if ( optAttrsObj ) this._docBuilder.attrs(optAttrsObj);
    
    return this;
  }
  
  contents(contents) {
    this._docBuilder.contents(contents);
    
    return this;
  }
  
  g(optContents) {
    return this.open('g', optContents);
  }
  
  transform(value) {
    return this.attr('transform', value);
  }
  
  translate(...translation) {
    translation = ( translation.length === 1 ) ?
      translation[0]:
      translation;
    
    return this.transform({ translate: translation });
  }
  
  rotate(...rotation) {
    rotation = ( rotation.length === 1 ) ?
      rotation[0]:
      rotation;
    
    return this.transform({ rotate: rotation });
  }
  
  circle(optAttrsObj) {
    return this.leaf('circle', optAttrsObj);
  }
  
  line(optAttrsObj) {
    return this.leaf('line', optAttrsObj);
  }
  
  rect(optAttrsObj) {
    return this.leaf('rect', optAttrsObj);
  }
  
  polyline(optPoints) {
    this.leaf('polyline');
    if ( optPoints ) this.points(optPoints);
    return this;
  }
  
  points(points) {
    return this.attr('points', points);
  }
  
  get() {
    return this._docBuilder.get();
  }
  
  appendTo(node) {
    this._docBuilder.appendTo(node);
  }
}
</script>
<body>
<svg id='svg' width='1000' height='600'></svg>
</body>

<script>
(() => {
const svg = new SvgBuilder();

// sky
svg.rect({
  x: 0, y: 0,
  width: 1000, height: 400,
  fill: 'blue'});

// ground
svg.rect({
  x: 0, y: 400,
  width: 1000, height: 200,
  fill: 'tan'});

// snowman body
svg.g().translate([180, 150]).contents(() => {
  svg.circle({
    cx: 0, cy: 350, r: 120,
    fill: 'white',
    stroke: 'black', strokeWidth: '1px'
  });
 
  svg.circle({
    cx: 0, cy: 190, r: 100,
    fill: 'white',
    stroke: 'black', strokeWidth: '1px'
  });
 
  // head
  svg.circle({
    cx: 0, cy: 50, r: 80,
    fill: 'white',
    stroke: 'black', strokeWidth: '1px'
  });

  svg.circle({
    cx: -20, cy: 25, r: 20,
    fill: 'white',
    stroke: 'black', strokeWidth: '1px'
  });
  svg.circle({cx: -20, cy: 35, r: 5, fill: 'black'});

  svg.circle({
    cx: +60, cy: 25, r: 20,
    fill: 'white',
    stroke: 'black', strokeWidth: '1px'
  });
  svg.circle({cx: +60, cy: 35, r: 5, fill: 'black'});

  svg.circle({
    cx: +20, cy: 75, r: 20,
    fill: 'red',
    stroke: 'black', strokeWidth: '1px'
  });
});

  
// tree
svg.g().translate(700, 100).contents(() => {
  svg.rect({
    x: 0, y: 0,
    width: 100, height: 400,
    fill: 'brown',
    stroke: 'black', strokeWidth: '1px'
  });

  svg.circle({
    cx: 50, cy: 0, r: 175,
    fill: 'green',
   stroke: 'black', strokeWidth: '1px'
  });
});

svg.polyline([[20, 20], [60, 40], [80, 20], [100, 40]]).rotate(45).attrs({
  fill: 'none',
  stroke: 'orange', strokeWidth: '10px'
});

svg.appendTo(document.getElementById('svg'));
})();
</script>
<!-- Novogorda -->
</html>
  